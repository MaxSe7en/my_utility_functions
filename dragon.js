const drawNumbers = [
    [
        8,
        6,
        7,
        2,
        2
    ],
    [
        2,
        0,
        2,
        5,
        3
    ],
    [
        6,
        5,
        2,
        0,
        5
    ],
    [
        4,
        6,
        3,
        3,
        8
    ],
    [
        9,
        8,
        0,
        6,
        3
    ],
    [
        1,
        9,
        7,
        0,
        7
    ],
    [
        2,
        0,
        5,
        8,
        4
    ],
    [
        1,
        9,
        0,
        4,
        4
    ],
    [
        0,
        6,
        3,
        6,
        3
    ],
    [
        3,
        8,
        3,
        7,
        6
    ],
    [
        5,
        8,
        1,
        4,
        5
    ],
    [
        0,
        5,
        4,
        5,
        7
    ],
    [
        9,
        5,
        8,
        5,
        5
    ],
    [
        7,
        5,
        9,
        4,
        4
    ],
    [
        1,
        6,
        4,
        7,
        2
    ],
    [
        5,
        0,
        1,
        6,
        5
    ],
    [
        3,
        2,
        9,
        3,
        1
    ],
    [
        2,
        6,
        8,
        0,
        9
    ],
    [
        5,
        5,
        0,
        2,
        6
    ],
    [
        7,
        0,
        8,
        7,
        1
    ],
    [
        5,
        9,
        7,
        9,
        0
    ],
    [
        3,
        2,
        5,
        3,
        0
    ],
    [
        1,
        1,
        9,
        0,
        0
    ],
    [
        5,
        9,
        7,
        6,
        0
    ],
    [
        8,
        3,
        9,
        7,
        6
    ],
    [
        1,
        7,
        7,
        1,
        7
    ],
    [
        2,
        0,
        8,
        3,
        9
    ],
    [
        0,
        4,
        6,
        1,
        9
    ],
    [
        3,
        5,
        4,
        6,
        0
    ],
    [
        1,
        7,
        3,
        1,
        7
    ],
    [
        5,
        5,
        5,
        2,
        8
    ],
    [
        6,
        9,
        3,
        6,
        8
    ],
    [
        7,
        6,
        7,
        5,
        2
    ],
    [
        7,
        3,
        8,
        8,
        6
    ],
    [
        3,
        2,
        8,
        7,
        0
    ],
    [
        5,
        7,
        0,
        2,
        7
    ],
    [
        0,
        9,
        7,
        6,
        8
    ],
    [
        0,
        5,
        5,
        2,
        0
    ],
    [
        2,
        1,
        3,
        0,
        7
    ],
    [
        6,
        6,
        9,
        0,
        1
    ],
    [
        1,
        9,
        6,
        9,
        2
    ],
    [
        7,
        3,
        0,
        9,
        1
    ],
    [
        0,
        0,
        3,
        4,
        7
    ],
    [
        5,
        5,
        3,
        5,
        2
    ],
    [
        4,
        0,
        8,
        4,
        0
    ],
    [
        1,
        4,
        8,
        4,
        0
    ],
    [
        6,
        2,
        3,
        6,
        5
    ],
    [
        1,
        1,
        7,
        3,
        7
    ],
    [
        1,
        9,
        3,
        1,
        0
    ],
    [
        8,
        8,
        1,
        2,
        9
    ],
    [
        4,
        1,
        6,
        4,
        5
    ],
    [
        0,
        9,
        9,
        0,
        5
    ],
    [
        4,
        1,
        9,
        1,
        4
    ],
    [
        3,
        6,
        7,
        5,
        5
    ],
    [
        3,
        5,
        3,
        4,
        4
    ],
    [
        0,
        4,
        8,
        4,
        4
    ],
    [
        5,
        3,
        5,
        4,
        9
    ],
    [
        0,
        4,
        5,
        0,
        5
    ],
    [
        1,
        7,
        5,
        7,
        3
    ],
    [
        6,
        3,
        7,
        3,
        5
    ],
    [
        5,
        1,
        1,
        0,
        6
    ],
    [
        3,
        2,
        7,
        8,
        4
    ],
    [
        0,
        3,
        5,
        2,
        0
    ],
    [
        6,
        7,
        7,
        1,
        7
    ],
    [
        8,
        3,
        5,
        4,
        8
    ],
    [
        4,
        4,
        3,
        6,
        5
    ],
    [
        3,
        4,
        7,
        1,
        5
    ],
    [
        1,
        2,
        0,
        6,
        3
    ],
    [
        7,
        6,
        9,
        1,
        1
    ],
    [
        2,
        8,
        4,
        4,
        3
    ],
    [
        0,
        2,
        2,
        9,
        2
    ],
    [
        0,
        5,
        0,
        5,
        0
    ],
    [
        1,
        6,
        6,
        6,
        7
    ],
    [
        5,
        6,
        0,
        9,
        2
    ],
    [
        0,
        7,
        6,
        4,
        2
    ],
    [
        9,
        0,
        4,
        4,
        9
    ],
    [
        8,
        9,
        3,
        8,
        2
    ],
    [
        2,
        3,
        4,
        4,
        5
    ],
    [
        4,
        6,
        4,
        0,
        4
    ],
    [
        7,
        8,
        7,
        8,
        7
    ],
    [
        3,
        2,
        4,
        4,
        9
    ],
    [
        4,
        3,
        8,
        7,
        3
    ],
    [
        8,
        1,
        2,
        7,
        1
    ],
    [
        8,
        9,
        5,
        9,
        5
    ],
    [
        6,
        6,
        3,
        1,
        2
    ],
    [
        7,
        5,
        9,
        3,
        4
    ],
    [
        5,
        1,
        0,
        9,
        8
    ],
    [
        2,
        1,
        4,
        6,
        8
    ],
    [
        9,
        8,
        3,
        0,
        7
    ],
    [
        4,
        4,
        6,
        2,
        1
    ],
    [
        4,
        1,
        2,
        1,
        6
    ],
    [
        0,
        6,
        8,
        9,
        4
    ],
    [
        1,
        5,
        0,
        9,
        3
    ],
    [
        9,
        7,
        7,
        5,
        0
    ],
    [
        9,
        1,
        6,
        1,
        5
    ],
    [
        4,
        8,
        5,
        1,
        5
    ],
    [
        0,
        9,
        9,
        2,
        5
    ],
    [
        2,
        5,
        9,
        5,
        7
    ],
    [
        6,
        9,
        3,
        4,
        9
    ]
].reverse();


function buildDragonTigerTree(drawNumbers, whatToAnalyze, type) {
    const tree = [];
    const road = analyzeDraw(drawNumbers, whatToAnalyze)[type];
    const roadLength = road.length;
    let row = 0;
    let col = 0;
    let whenColIncreaseByMaxRows = 0;
    let columnLeader = "";
    let countLetterA = 0;
    const dua = new Map();
    const visited = new Set();

    for (let i = 0; i < roadLength; i++) {
        const previousLetter = road[i - 1];
        const currentLetter = road[i];
        const nextLetter = road[i + 1];

        if (currentLetter !== previousLetter && previousLetter !== "A" && currentLetter !== "A") {
            col = whenColIncreaseByMaxRows;
            columnLeader = currentLetter;
            console.log(whenColIncreaseByMaxRows, "currentLetter", currentLetter)
        }

        // if( countLetterA > 2 && columnLeader !== "T" && previousLetter === "A" ){
        //     console.log("does it come here", currentLetter !== "A", columnLeader !== "T")
        //     row++;
        // } else 
//  if( previousLetter == "A" && countLetterA > 0 && currentLetter !== previousLetter){
//                 row =0;
//                 col++
//             } 
        // if (currentLetter === columnLeader) {
        //     row++;
        // }
        if (previousLetter !== undefined && currentLetter !== "A" && currentLetter !== previousLetter) {
            // console.log("come here", currentLetter !== "A", currentLetter !== previousLetter)
            if (countLetterA >= 2 && columnLeader !== "T" && previousLetter === "A") {
                console.log("does it come here", currentLetter !== "A", columnLeader !== "T")
                row++;
            }
            else if (currentLetter === columnLeader && previousLetter == "A" && countLetterA === 1) {
                row++;
            } 
            // else if( previousLetter == "A" && countLetterA > 0 && currentLetter !== previousLetter){
            //     row =0;
            //     col++
            // } 
            else {
                //     whenColIncreaseByMaxRows = col;
                // columnLeader = currentLetter;
                console.log("come here and change column", currentLetter, previousLetter, countLetterA, columnLeader)
                col = whenColIncreaseByMaxRows;
                row = 0;
                col++;

            }
            if (row === 0) {
                whenColIncreaseByMaxRows = col;
                // console.log("sdfkaghsdkfkahsdfghkasdhfkasdf")
                columnLeader = currentLetter;
            }
        } else if (currentLetter === "A") {
            row++;
        } else if (countLetterA >= 2 && columnLeader !== "T" && previousLetter === "A") {
            row++;
        } else if (currentLetter === previousLetter) {
            row++;

            const prevCol = col - 1;
            const prev = dua.get(row + "|" + prevCol);

            if (prev === currentLetter) {
                // console.log("come here")
                row--;
                col++;
            }

        } else if (currentLetter !== previousLetter && currentLetter !== nextLetter && currentLetter !== "A") {
            col = 0;
            whenColIncreaseByMaxRows = col;
            columnLeader = currentLetter;
        }

        if (row > 5) {
            row = 5;
            col++;
        }


        if (currentLetter === "A") {
            countLetterA++;
        } else {
            countLetterA = 0;
        }

        //   if (countLetterA > 2) {
        //     // console.log("countLetterA: " + countLetterA)
        //     //     row = 0;
        //     //     col++;
        //     //     countLetterA = 0;
        //   }
        // console.log("column leader: ", columnLeader)
        console.log("row: " + row + " col: " + col + " currentLetter: " + currentLetter + " previousLetter: " + previousLetter + " nextLetter " + nextLetter )//+ " countLetterA: " + countLetterA)//, " columnLeader: " + columnLeader)
        const newItem = [row, col, currentLetter];
        console.log("visited: ", visited)
        if (visited.has(row + "|" + col)) {
            row--;
            col++;
            newItem[0] = row;
            newItem[1] = col;
        } else {
            visited.add(row + "|" + col);
        }

        dua.set(row + "|" + col, currentLetter);

        tree.push(newItem);
    }
    console.log("tree: ", tree)
    return tree;
}
// function buildDragonTigerTree(drawNumbers, whatToAnalyze, type) {
//     const tree = [];
//     const analyzedResults = analyzeDraw(drawNumbers, whatToAnalyze)[type];


//     let row = 0;
//     let col = 0;
//     let whenColIncreaseByMaxRows = 0;
//     let columnLeader = ""
//     let dua = {};

//     analyzedResults.forEach((_, i) => {
//         let previousLetter = analyzedResults[i - 1];
//         let currentLetter = analyzedResults[i];
//         let nextLetter = analyzedResults[i + 1];
//         let newItem = [];

//         if (currentLetter !== previousLetter) {
//             col = whenColIncreaseByMaxRows;
//         }
//         if (previousLetter !== undefined && currentLetter !== previousLetter) {
//             row = 0;
//             col++;
//             if (row === 0) {
//                 whenColIncreaseByMaxRows = col;
//                 columnLeader = currentLetter;
//             }
//         } else if (currentLetter === previousLetter) {
//             row++;

//             let prevCol = col - 1;
//             const prev = dua[row + "|" + prevCol];

//             if (prev === currentLetter) {
//                 row--;
//                 col++;
//             }
//         } else if (currentLetter !== previousLetter && currentLetter !== nextLetter) {
//             col = 0;
//             whenColIncreaseByMaxRows = col;
//             columnLeader = currentLetter;
//         }

//         if (row > 5) {
//             row = 5;
//             col++;
//         }
//         newItem = [row, col, currentLetter];

//         let duplicate = tree.some((item) => item[0] === newItem[0] && item[1] === newItem[1]);

//         if (duplicate) {
//             row--;
//             col++;
//             newItem = [row, col, currentLetter];
//         }

//         dua[row + "|" + col] = currentLetter;
//         tree.push(newItem);
//     });
//     console.log(tree)
//     return tree;
// }



const timerStart = performance.now()




// Get the table element by ID
const table = document.getElementById("grid");

// Loop through the data and add rows to the table
// buildDragonTigerTree(drawNumbers, "sum", "D/T")

document.onload = createTable(6, 100);

function createTable(rows, cols) {
    for (let i = 0; i < rows; i++) {
        const row = table.insertRow();
        for (let j = 0; j < cols; j++) {
            const cell = row.insertCell();
            // cell.textContent = ""; // Initially empty
            cell.textContent = i+""+j; // Initially empty
        }
    }
}


buildDragonTigerTree(drawNumbers, "sum", "D/T").forEach(rowData => {
    const [rowIndex, colIndex, value] = rowData;
    const row = table.rows[rowIndex];
    if (row) {
        const cell = row.cells[colIndex];
        if (cell) {
            cell.textContent = value;
        }
        if (value === "D") {
            cell.style.color = "blue";
        } else if (value === "T") {
            cell.style.color = "red";
        } else if (value === "A") {
            cell.style.color = "green";
        }
        cell.style.fontWeight = "bold";
    }
});;
const timerEnd = performance.now()


// Create an empty table with a certain number of rows and columns
// createTable(5, 5); // Adjust the number of rows and columns as needed









function firstAndLast(arr) {
    if (arr.length === 0) {
        return []; // Return an empty array for an empty input array.
    }

    const first = arr[0];
    const last = arr[arr.length - 1];

    return [first, last];
}

// Helper functions
function getOddEven(num) {
    return num % 2 === 0 ? "E" : "O";
}

function getBigSmallForSum(sum) {
    return sum >= 23 && sum <= 45 ? "B" : "S";
}

function getDragonTiger(lastTwo) {
    if (lastTwo[0] > lastTwo[1]) {
        return "D";
    } else if (lastTwo[0] < lastTwo[1]) {
        return "T";
    } else {
        return "A";
    }
}

function analyzeDraw(drawNumbers, whatToAnalyze) {
    const results = {
        "Big/Small": [], // Add an array to store detailed dragon-tiger-tie counts
        "Odd/Even": [], // Add an array to store detailed
        "P/C": [],
        "D/T": [],
    };


    for (const element of drawNumbers) {
        const draw = element;

        // let ball = draw[parseInt(whatToAnalyze) - 1];

        // let bigSmall = getBigSmallForBall(ball);

        let ball;
        if (whatToAnalyze === "sum") {
            ball = draw.reduce((a, b) => a + b, 0);
        } else {
            ball = draw[parseInt(whatToAnalyze) - 1];
        }

        let oddEven, bigSmall, primeComposite, dragonTiger;
        // console.log("ball", ball);
        if (whatToAnalyze === "sum") {
            // console.log("dsfkjksdafkhsadhfkhsdakhfklsdfklhsdaf")
            oddEven = getOddEven(ball);
            bigSmall = getBigSmallForSum(ball);

            let lastTwo = firstAndLast(draw);
            dragonTiger = getDragonTiger(lastTwo);
        } else {
            oddEven = getOddEven(ball);
            bigSmall = getBigSmallForBall(ball);

            primeComposite = getPrimeComposite(ball);
            dragonTiger = getDragonTiger(["dragon", "tiger", "tie"]); // Initialize dragonTiger value
        }
        // Add the bigSmall value to the results array
        results["Big/Small"].push(bigSmall);
        results["Odd/Even"].push(oddEven);
        results["P/C"].push(primeComposite);
        results["D/T"].push(dragonTiger);

    }

    console.log("results", results["D/T"])
    return results;
}