const drawNumbers = [
    [
        0,
        7,
        7,
        2,
        4
    ],
    [
        5,
        3,
        1,
        6,
        0
    ],
    [
        1,
        1,
        6,
        1,
        9
    ],
    [
        4,
        9,
        6,
        0,
        4
    ],
    [
        9,
        9,
        6,
        4,
        6
    ],
    [
        1,
        3,
        5,
        4,
        0
    ],
    [
        4,
        8,
        8,
        2,
        2
    ],
    [
        6,
        5,
        0,
        9,
        9
    ],
    [
        4,
        3,
        0,
        4,
        8
    ],
    [
        4,
        5,
        7,
        7,
        1
    ],
    [
        0,
        9,
        1,
        9,
        0
    ],
    [
        4,
        7,
        9,
        2,
        9
    ],
    [
        9,
        6,
        0,
        1,
        4
    ],
    [
        8,
        7,
        4,
        7,
        1
    ],
    [
        5,
        5,
        2,
        1,
        0
    ],
    [
        6,
        7,
        6,
        3,
        1
    ],
    [
        3,
        0,
        9,
        1,
        3
    ],
    [
        8,
        7,
        4,
        3,
        8
    ],
    [
        2,
        6,
        3,
        8,
        1
    ],
    [
        5,
        1,
        6,
        4,
        4
    ],
    [
        7,
        6,
        8,
        3,
        3
    ],
    [
        5,
        6,
        7,
        1,
        1
    ],
    [
        1,
        8,
        3,
        9,
        9
    ],
    [
        2,
        9,
        6,
        3,
        3
    ],
    [
        0,
        4,
        6,
        5,
        4
    ],
    [
        1,
        0,
        5,
        6,
        9
    ],
    [
        7,
        9,
        5,
        9,
        8
    ],
    [
        3,
        2,
        9,
        9,
        3
    ],
    [
        3,
        0,
        1,
        0,
        6
    ],
    [
        9,
        4,
        2,
        7,
        8
    ],
    [
        7,
        5,
        4,
        8,
        3
    ],
    [
        4,
        5,
        6,
        5,
        9
    ],
    [
        7,
        7,
        0,
        5,
        4
    ],
    [
        5,
        3,
        4,
        8,
        9
    ],
    [
        9,
        2,
        3,
        1,
        9
    ],
    [
        2,
        9,
        9,
        4,
        4
    ],
    [
        5,
        7,
        1,
        2,
        4
    ],
    [
        5,
        8,
        7,
        5,
        4
    ],
    [
        9,
        6,
        4,
        4,
        7
    ],
    [
        3,
        2,
        9,
        5,
        1
    ],
    [
        9,
        9,
        6,
        7,
        7
    ],
    [
        2,
        7,
        5,
        0,
        2
    ],
    [
        3,
        8,
        7,
        0,
        0
    ],
    [
        2,
        2,
        7,
        0,
        6
    ],
    [
        8,
        3,
        6,
        6,
        2
    ],
    [
        0,
        7,
        2,
        3,
        4
    ],
    [
        4,
        2,
        9,
        3,
        7
    ],
    [
        1,
        0,
        3,
        9,
        6
    ],
    [
        0,
        0,
        0,
        7,
        1
    ],
    [
        0,
        3,
        1,
        7,
        9
    ],
    [
        6,
        4,
        8,
        9,
        5
    ],
    [
        1,
        4,
        4,
        5,
        8
    ],
    [
        5,
        3,
        6,
        8,
        8
    ],
    [
        6,
        2,
        6,
        8,
        9
    ],
    [
        8,
        2,
        8,
        8,
        3
    ],
    [
        7,
        8,
        8,
        3,
        7
    ],
    [
        2,
        8,
        9,
        2,
        8
    ],
    [
        1,
        9,
        2,
        1,
        6
    ],
    [
        5,
        0,
        9,
        7,
        3
    ],
    [
        9,
        0,
        8,
        2,
        6
    ],
    [
        2,
        5,
        1,
        5,
        7
    ],
    [
        8,
        1,
        3,
        1,
        6
    ],
    [
        8,
        3,
        0,
        9,
        8
    ],
    [
        2,
        5,
        9,
        7,
        0
    ],
    [
        5,
        9,
        6,
        9,
        7
    ],
    [
        9,
        6,
        1,
        8,
        7
    ],
    [
        1,
        8,
        2,
        6,
        0
    ],
    [
        1,
        0,
        5,
        1,
        0
    ],
    [
        5,
        7,
        8,
        9,
        3
    ],
    [
        2,
        1,
        7,
        9,
        6
    ],
    [
        1,
        9,
        5,
        9,
        9
    ],
    [
        7,
        7,
        2,
        8,
        5
    ],
    [
        8,
        8,
        7,
        0,
        0
    ],
    [
        3,
        3,
        9,
        4,
        2
    ],
    [
        2,
        6,
        8,
        8,
        5
    ],
    [
        7,
        8,
        4,
        4,
        5
    ],
    [
        8,
        4,
        6,
        2,
        1
    ],
    [
        0,
        2,
        5,
        8,
        3
    ],
    [
        7,
        9,
        3,
        4,
        1
    ],
    [
        4,
        5,
        9,
        7,
        4
    ],
    [
        6,
        8,
        3,
        7,
        1
    ],
    [
        1,
        2,
        4,
        3,
        3
    ],
    [
        2,
        9,
        9,
        5,
        4
    ],
    [
        5,
        2,
        4,
        0,
        9
    ],
    [
        3,
        5,
        0,
        2,
        0
    ],
    [
        9,
        1,
        9,
        2,
        6
    ],
    [
        4,
        4,
        5,
        9,
        4
    ],
    [
        2,
        5,
        2,
        3,
        3
    ],
    [
        6,
        0,
        4,
        4,
        5
    ],
    [
        2,
        5,
        8,
        4,
        1
    ],
    [
        6,
        0,
        6,
        9,
        4
    ],
    [
        8,
        4,
        0,
        0,
        4
    ],
    [
        9,
        3,
        0,
        8,
        8
    ],
    [
        1,
        9,
        1,
        1,
        0
    ],
    [
        0,
        9,
        8,
        5,
        9
    ],
    [
        3,
        8,
        8,
        0,
        1
    ],
    [
        4,
        2,
        1,
        6,
        7
    ],
    [
        4,
        0,
        4,
        2,
        0
    ],
    [
        4,
        0,
        8,
        7,
        6
    ]
].reverse();

function buildDragonTigerTree(drawNumbers, whatToAnalyze, type) {
 
  const maxRows = 5;
  const tree = [];
  const road = analyzeDraw(drawNumbers, whatToAnalyze)[type];
  const roadLength = road.length;
  let row = 0;
  let col = 0;
  const maxNumberOfRows = 5;
  let whenColIncreaseByMaxRows = 0;
  let columnLeader = "";
  let countLetterA = 0;
  const dua = new Map();
  const visited = new Set();
  let counter = 0;
  // let columnLeader = road[0];

  for (let i = 0; i < road.length; i++) {
    const currentLetter = road[i];
    const previousLetter = road[i - 1];
    //get the first letter before the previous letter
    const previousLetterBeforeLetterA = road[i - 2];
    const nextLetter = road[i + 1];
    const firstItem = road[0];
    if (firstItem == "A" && i == 0) {
      row = 0;
      col = 0;
    } else {
      if (currentLetter !== "A") {
        if (
          previousLetter === "A" &&
          countLetterA === 1 &&
          firstItem == "A" &&
          col == 0
        ) {
          console.log("dsfkhsdkafhksdahfkhasdf");
          row++;
        } else if (columnLeader === "D" && countLetterA >= 2) {
          row++;
          console.log(
            "---------------------------------------------------00000000000000000000000000000000",
            currentLetter,
            row,
            col
          );
        } else if (columnLeader === "T" && countLetterA >= 2) {
          row++;
        } else if (
          previousLetter === "A" &&
          countLetterA === 1 &&
          previousLetterBeforeLetterA == currentLetter
        ) {
          row++;
        }
        //   else if (previousLetter === "A" && countLetterA === 1 && firstItem == "A"&& i == 0){
        //     row++
        //   }
        else {
          if (currentLetter !== previousLetter) {
            col = whenColIncreaseByMaxRows;
            columnLeader = currentLetter;
          }
          if (
            previousLetter !== undefined &&
            currentLetter !== previousLetter
          ) {
            row = 0;
            col++;
            if (row === 0) {
              whenColIncreaseByMaxRows = col;
              // columnLeader = currentLetter;
            }
          } else if (currentLetter === previousLetter) {
            row++;

            let prevCol = col - 1;
            const prev = dua[row + "|" + prevCol];

            if (prev === currentLetter) {
              row--;
              col++;
            }
          } else if (
            currentLetter !== previousLetter &&
            currentLetter !== nextLetter
          ) {
            col = 0;
            whenColIncreaseByMaxRows = col;
            // columnLeader = currentLetter;
          }
        }
        if (row > 5) {
          row = 5;
          col++;
        }
        counter++;
      } else {
        // // Rule 3 - allow 'T' or 'D' after 'A' if column leader is 'D'
        if (columnLeader === "D") {
          // stay in column
          console.log("D");
          row++;
        } else {
          row++;
        }
        // // Otherwise, only 'A' can follow
        // else {
        //     col++;
        //     row = 0;
        // }
        // row++
        counter++;
      }
    }
    // Increment row and handle max rows
    // row++;
    if (row > maxNumberOfRows) {
      row = maxNumberOfRows;
      col++;
    }

    if (currentLetter === "A") {
      countLetterA++;
    } else {
      countLetterA = 0;
    }

    // Build item for tree
    let newItem = [row, col, currentLetter];

    // if (visited.has(row + "|" + col)) {
    //     row--;
    //     col++;
    //     newItem[0] = row;
    //     newItem[1] = col;
    // } else {
    //     visited.add(row + "|" + col);
    // }

    // // counter++
    // // console.log("counter ========>", counter)
    // dua.set(row + "|" + col, currentLetter);
    console.log("countLetterA", countLetterA);
    let duplicate = tree.some(
      (item) => item[0] === newItem[0] && item[1] === newItem[1]
    );

    if (duplicate) {
      row--;
      col++;
      newItem = [row, col, currentLetter];
    }

    dua[row + "|" + col] = currentLetter;
    tree.push(newItem);
  }
  console.log(tree);

  return tree;
}
// function buildDragonTigerTree(drawNumbers, whatToAnalyze, type) {
//     const tree = [];
//     const road = analyzeDraw(drawNumbers, whatToAnalyze)[type];
//     const roadLength = road.length;
//     let row = 0;
//     let col = 0;
//     const maxNumberOfRows = 5;
//     let whenColIncreaseByMaxRows = 0;
//     let columnLeader = "";
//     let countLetterA = 0;
//     const dua = new Map();
//     const visited = new Set();
//     let counter = 0

//     for (let i = 0; i < roadLength; i++) {
//         const previousLetter = road[i - 1];
//         //get the first letter before the previous letter
//         const previousLetterBefore = road[i - 2];
//         const currentLetter = road[i];
//         const nextLetter = road[i + 1];

//         //    console.log(previousLetter, currentLetter, nextLetter, countLetterA, previousLetterBefore, columnLeader)
//         // console.log("previousLetter: ", previousLetter, "currentLetter: ", currentLetter, "nextLetter: ", nextLetter, "countLetterA: ", countLetterA, "previousLetterBefore: ", previousLetterBefore, "columnLeader: ", columnLeader)
//         // if (currentLetter !== previousLetter && previousLetter !== "A" && currentLetter !== "A") {
//         //     // col = whenColIncreaseByMaxRows;
//         //     // columnLeader = currentLetter;
//         //     console.log(whenColIncreaseByMaxRows, "currentLetter", currentLetter)
//         // }
//         if (previousLetter !== undefined && currentLetter !== previousLetter && currentLetter !== "A" && previousLetter != "A") {
//             // console.log("rows ", row, "col", col, "currentLetter", currentLetter)
//             col = whenColIncreaseByMaxRows
//             columnLeader = currentLetter
//             row = 0
//             col++
//             if (row === 0) {
//                 counter++
//                 console.log("biiiiiiiiiiiiiiiiiiiiiiiiig jdkfjksdfjksda", row, col, currentLetter, counter)

//                 whenColIncreaseByMaxRows = col;
//             }
//         }
//         //    A A or D D or T T or A T or T A or D A or A D
//         // else if (previousLetter === currentLetter || currentLetter === "A") {
//         //     // if( previousLetter === "A" )
//         //     // console.log("-----------------------------------",countLetterA, countLetterA >= 2)
//         //     // D A A followed by T
//         //     // if( countLetterA >= 2 && columnLeader != "T"){
//         //     //     row = 0;
//         //     //     col++
//         //     // }
//         //     // // but T A A cannot be followed by D
//         //     // else if(countLetterA >= 2 && columnLeader == "T" ){
//         //     //     row = 0;
//         //     //     col++
//         //     // }
//         //     // else{
//         //     //     row++
//         //     // }
//         //     // col = whenColIncreaseByMaxRows
//         //     row++
//         //     let prevCol = col - 1;
//         //     const prev = dua[row + "|" + prevCol];

//         //     if (prev === currentLetter) {
//         //         row--;
//         //         col++;
//         //     }
//         // } else if (countLetterA >= 2 && columnLeader != "T" && currentLetter == columnLeader) {
//         //     // row = 0;
//         //     row++

//         // }

//         // else if (countLetterA <= 1 && columnLeader != "T" && currentLetter != columnLeader && previousLetter != undefined) {
//         //     console.log("biiiiiiiiiiiiiiiiiiiiiiiiig boy", row, col, currentLetter)

//         // }
//         // else if(currentLetter !== previousLetter && previousLetter != undefined){
//         //     console.log("biiiiiiiiiig boooooooooooooooooooy", row, col, currentLetter)
//         //     col = whenColIncreaseByMaxRows
//         //     row = 0
//         //     col++
//         // }

//         if (currentLetter === "A") {
//             countLetterA++;
//         } else {
//             countLetterA = 0;
//         }

//         if (row > maxNumberOfRows) {
//             row = maxNumberOfRows;
//             // whenColIncreaseByMaxRows = col;
//             col++;
//         }
//         // if( countLetterA >= 2 && columnLeader != "T" && currentLetter != columnLeader){
//         //     // row = 0;
//         //     // row++
//         //     console.log("biiiiiiiiiiiiiiiiiiiiiiiiig boy", row, col)
//         // }
//         // but T A A cannot be followed by D
//         // else if(countLetterA >= 2 && columnLeader == "T" ){
//         //     row = 0;
//         //     col++
//         // }
//         console.log("currentLetter: ", currentLetter, countLetterA)
//         const newItem = [row, col, currentLetter];
//         // console.log("visited: ", visited)

//         if (visited.has(row + "|" + col)) {
//             row--;
//             col++;
//             newItem[0] = row;
//             newItem[1] = col;
//         } else {
//             visited.add(row + "|" + col);
//         }

//         dua.set(row + "|" + col, currentLetter);

//         tree.push(newItem);

//         if (row === 0 && col === 12) {
//             // console.log("sitsss", currentLetter, previousLetter, countLetterA)
//             // alert(currentLetter)
//             // console.log("sitsss", road.slice(13, 24))
//         }
//     }
//     console.log("tree: ", tree)
//     return tree;
// }
// function buildDragonTigerTree(drawNumbers, whatToAnalyze, type) {
//     const tree = [];
//     const analyzedResults = analyzeDraw(drawNumbers, whatToAnalyze)[type];

//     let row = 0;
//     let col = 0;
//     let whenColIncreaseByMaxRows = 0;
//     let columnLeader = ""
//     let dua = {};

//     analyzedResults.forEach((_, i) => {
//         let previousLetter = analyzedResults[i - 1];
//         let currentLetter = analyzedResults[i];
//         let nextLetter = analyzedResults[i + 1];
//         let newItem = [];

//         if (currentLetter !== previousLetter) {
//             col = whenColIncreaseByMaxRows;
//         }
//         if (previousLetter !== undefined && currentLetter !== previousLetter) {
//             row = 0;
//             col++;
//             if (row === 0) {
//                 whenColIncreaseByMaxRows = col;
//                 columnLeader = currentLetter;
//             }
//         } else if (currentLetter === previousLetter) {
//             row++;

//             let prevCol = col - 1;
//             const prev = dua[row + "|" + prevCol];

//             if (prev === currentLetter) {
//                 row--;
//                 col++;
//             }
//         } else if (currentLetter !== previousLetter && currentLetter !== nextLetter) {
//             col = 0;
//             whenColIncreaseByMaxRows = col;
//             columnLeader = currentLetter;
//         }

//         if (row > 5) {
//             row = 5;
//             col++;
//         }
//         newItem = [row, col, currentLetter];

//         let duplicate = tree.some((item) => item[0] === newItem[0] && item[1] === newItem[1]);

//         if (duplicate) {
//             row--;
//             col++;
//             newItem = [row, col, currentLetter];
//         }

//         dua[row + "|" + col] = currentLetter;
//         tree.push(newItem);
//     });
//     console.log(tree)
//     return tree;
// }

const timerStart = performance.now();

// Get the table element by ID
const table = document.getElementById("grid");

// Loop through the data and add rows to the table
// buildDragonTigerTree(drawNumbers, "sum", "D/T")

document.onload = createTable(6, 100);

function createTable(rows, cols) {
  for (let i = 0; i < rows; i++) {
    const row = table.insertRow();
    for (let j = 0; j < cols; j++) {
      const cell = row.insertCell();
      cell.textContent = ""; // Initially empty
      // cell.textContent = i + "" + j; // Initially empty
    }
  }
}

buildDragonTigerTree(drawNumbers, "sum", "D/T").forEach((rowData) => {
  const [rowIndex, colIndex, value] = rowData;
  const row = table.rows[rowIndex];
  if (row) {
    const cell = row.cells[colIndex];
    if (cell) {
      // cell.textContent = rowIndex + " " + value + " " + colIndex;
      cell.textContent = value;
    }
    if (value === "D") {
      cell.style.color = "blue";
    } else if (value === "T") {
      cell.style.color = "red";
    } else if (value === "A") {
      cell.style.color = "green";
    }
    cell.style.fontWeight = "bold";
  }
});
const timerEnd = performance.now();

// Create an empty table with a certain number of rows and columns
// createTable(5, 5); // Adjust the number of rows and columns as needed

function firstAndLast(arr) {
  if (arr.length === 0) {
    return []; // Return an empty array for an empty input array.
  }

  const first = arr[0];
  const last = arr[arr.length - 1];

  return [first, last];
}

// Helper functions
function getOddEven(num) {
  return num % 2 === 0 ? "E" : "O";
}

function getBigSmallForSum(sum) {
  return sum >= 23 && sum <= 45 ? "B" : "S";
}

function getDragonTiger(lastTwo) {
  if (lastTwo[0] > lastTwo[1]) {
    return "D";
  } else if (lastTwo[0] < lastTwo[1]) {
    return "T";
  } else {
    return "A";
  }
}

function analyzeDraw(drawNumbers, whatToAnalyze) {
  const results = {
    "Big/Small": [], // Add an array to store detailed dragon-tiger-tie counts
    "Odd/Even": [], // Add an array to store detailed
    "P/C": [],
    "D/T": [],
  };

  for (const element of drawNumbers) {
    const draw = element;

    // let ball = draw[parseInt(whatToAnalyze) - 1];

    // let bigSmall = getBigSmallForBall(ball);

    let ball;
    if (whatToAnalyze === "sum") {
      ball = draw.reduce((a, b) => a + b, 0);
    } else {
      ball = draw[parseInt(whatToAnalyze) - 1];
    }

    let oddEven, bigSmall, primeComposite, dragonTiger;
    // console.log("ball", ball);
    if (whatToAnalyze === "sum") {
      // console.log("dsfkjksdafkhsadhfkhsdakhfklsdfklhsdaf")
      oddEven = getOddEven(ball);
      bigSmall = getBigSmallForSum(ball);

      let lastTwo = firstAndLast(draw);
      dragonTiger = getDragonTiger(lastTwo);
    } else {
      oddEven = getOddEven(ball);
      bigSmall = getBigSmallForBall(ball);

      primeComposite = getPrimeComposite(ball);
      dragonTiger = getDragonTiger(["dragon", "tiger", "tie"]); // Initialize dragonTiger value
    }
    // Add the bigSmall value to the results array
    results["Big/Small"].push(bigSmall);
    results["Odd/Even"].push(oddEven);
    results["P/C"].push(primeComposite);
    results["D/T"].push(dragonTiger);
  }

  console.log("results", results["D/T"]);
  return results;
}

/*

 for (let i = 0; i < roadLength; i++) {
        const previousLetter = road[i - 1];
        //get the first letter before the previous letter
        const previousLetterBefore = road[i - 2];
        const currentLetter = road[i];
        const nextLetter = road[i + 1];

        if (currentLetter !== previousLetter && previousLetter !== "A" && currentLetter !== "A") {
            col = whenColIncreaseByMaxRows;
            columnLeader = currentLetter;
            console.log(whenColIncreaseByMaxRows, "currentLetter", currentLetter)
        }

        console.log("currentLetter, previousLetter", currentLetter, previousLetter)

        if (previousLetter !== undefined && currentLetter !== previousLetter && currentLetter !== "A") {
            // console.log("come here", currentLetter !== "A", currentLetter !== previousLetter)

            if (countLetterA >= 2 && columnLeader !== "T" && previousLetter === "A") {
                // console.log("does it come here", currentLetter !== "A", columnLeader !== "T")
                // col = whenColIncreaseByMaxRows;
                whenColIncreaseByMaxRows = col;

                row++;
            }
            // else if (currentLetter === columnLeader && previousLetter == "A" && countLetterA === 1 && previousLetterBefore !== currentLetter) {
            //     col = whenColIncreaseByMaxRows;

            //     row = 0;
            //     col++;
            //     console.log("good grace")
            // }
            else if (currentLetter === columnLeader && countLetterA === 1) {
                console.log("last good grace", previousLetterBefore, whenColIncreaseByMaxRows)
                // if (previousLetterBefore !== currentLetter) {
                //     // col = whenColIncreaseByMaxRows;
                //     console.log("good grace", whenColIncreaseByMaxRows)
                //     col = 11
                //     row = 0;
                //     col++;
                // }

                // else {
                //     row++;
                // }
                row++;
                // alert()
                console.log("--==========================--", "come here and change column", currentLetter, previousLetter, countLetterA, columnLeader, previousLetterBefore)
            }
            else if (previousLetter == "A" && countLetterA >= 2 && columnLeader === "T" && currentLetter !== previousLetter) {
                // console.log("im actually here")
                whenColIncreaseByMaxRows = col;
                
                row++;
            }
            // else if(){

            // }
            else {

                //     whenColIncreaseByMaxRows = col;
                // columnLeader = currentLetter;
                console.log("come here and change column", currentLetter, previousLetter, countLetterA, columnLeader)
                col = whenColIncreaseByMaxRows;
                row = 0;
                col++;

            }

            if (row === 0) {
                whenColIncreaseByMaxRows = col;
                // console.log("sdfkaghsdkfkahsdfghkasdhfkasdf")
                columnLeader = currentLetter;
            }
        } else if (currentLetter === "A") {
            row++;
        }
        else if (currentLetter === previousLetter) {
            row++;

            const prevCol = col - 1;
            const prev = dua.get(row + "|" + prevCol);

            if (prev === currentLetter) {
                // console.log("come here")
                row--;
                col++;
            }

        }
        else if (currentLetter !== previousLetter && currentLetter !== nextLetter && currentLetter !== "A") {
            col = 0;
            whenColIncreaseByMaxRows = col;
            columnLeader = currentLetter;
        }

        if (row > 5) {
            row = 5;
            col++;
        }


        if (currentLetter === "A") {
            countLetterA++;
        } else {
            countLetterA = 0;
        }
        // if(previousLetter === "A" && currentLetter === "T"){
        //     // row++;
        //     col = whenColIncreaseByMaxRows;
        //         row = 0;
        //         col++;
        // }
        //   if (countLetterA > 2) {
        //     // console.log("countLetterA: " + countLetterA)
        //     //     row = 0;
        //     //     col++;
        //     //     countLetterA = 0;
        //   }
        // console.log("column leader: ", columnLeader)
        // console.log("row: " + row + " col: " + col + " currentLetter: " + currentLetter + " previousLetter: " + previousLetter + " nextLetter " + nextLetter)//+ " countLetterA: " + countLetterA)//, " columnLeader: " + columnLeader)
        // console.log(previousLetter !== undefined && currentLetter !== "A" && currentLetter !== previousLetter , " currentLetter: " + currentLetter + " previousLetter: " + previousLetter + " nextLetter " + nextLetter, "column leader", columnLeader)
        const newItem = [row, col, currentLetter];
        // console.log("visited: ", visited)
        if (visited.has(row + "|" + col)) {
            row--;
            col++;
            newItem[0] = row;
            newItem[1] = col;
        } else {
            visited.add(row + "|" + col);
        }

        dua.set(row + "|" + col, currentLetter);

        tree.push(newItem);
        if (row === 0 && col === 12) {
            console.log("sitsss", currentLetter, previousLetter, countLetterA)
            // alert(currentLetter)
            console.log("sitsss", road.slice(13, 24))
        }
    }

*/
